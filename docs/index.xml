<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
      <title>nerdypepper's μblog</title>
      <link>https://peppe.rs</link>
      <description>programming, design, software</description>
      <atom:link href="https://peppe.rs/index.xml" rel="self" type="application/rss+xml" />
      <image>
        <title>nerdypepper's μblog</title>
        <url>https://u.peppe.rs/n.png</url>
        <link>https://peppe.rs</link>
      </image>
      <language>en-us</language>
      <copyright>Creative Commons BY-NC-SA 4.0</copyright>
      <item>
<title>Turing Complete Type Systems</title>
<description><p>Rust’s type system is Turing complete:</p>
<ul>
<li><a href="https://github.com/doctorn/trait-eval/">FizzBuzz with Rust Traits</a></li>
<li><a href="https://github.com/Ashymad/fortraith">A Forth implementation with Rust Traits</a></li>
</ul>
<p>It is impossible to determine if a program written in a generally Turing complete system will ever stop. That is, it is impossible to write a program <code>f</code> that determines if a program <code>g</code>, where <code>g</code> is written in a Turing complete programming language, will ever halt. The <a href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a> is in fact, an <a href="https://en.wikipedia.org/wiki/Undecidable_problem">undecidable problem</a>.</p>
<p><em>How is any of this relevant?</em></p>
<p>Rust performs compile-time type inference. The type checker, in turn, compiles and infers types, I would describe it as a compiler inside a compiler. It is possible that <code>rustc</code> may never finish compiling your Rust program! I lied, <code>rustc</code> stops after a while, after hitting the recursion limit.</p>
<p>I understand that this post lacks content.</p></description>
<link>https://peppe.rs/posts/turing_complete_type_systems/</link>
<pubDate>Thu, 18 Jun 2020 05:18:00 +0000</pubDate>
<guid>https://peppe.rs/posts/turing_complete_type_systems/</guid>
</item>
<item>
<title>Auto-currying Rust Functions</title>
<description><p>This post contains a gentle introduction to procedural macros in Rust and a guide to writing a procedural macro to curry Rust functions. The source code for the entire library can be found <a href="https://github.com/nerdypepper/cutlass">here</a>. It is also available on <a href="https://crates.io/crates/cutlass">crates.io</a>.</p>
<p>The following links might prove to be useful before getting started:</p>
<ul>
<li><a href="https://doc.rust-lang.org/reference/procedural-macros.html">Procedural Macros</a></li>
<li><a href="https://en.wikipedia.org/wiki/Currying">Currying</a></li>
</ul>
<p>Or you can pretend you read them, because I have included a primer here :)</p>
<h3 id="contents">Contents</h3>
<ol type="1">
<li><a href="#currying">Currying</a><br />
</li>
<li><a href="#procedural-macros">Procedural Macros</a><br />
</li>
<li><a href="#definitions">Definitions</a><br />
</li>
<li><a href="#refinement">Refinement</a><br />
</li>
<li><a href="#the-in-betweens">The In-betweens</a><br />
     5.1 <a href="#dependencies">Dependencies</a><br />
     5.2 <a href="#the-attribute-macro">The attribute macro</a><br />
     5.3 <a href="#function-body">Function Body</a><br />
     5.4 <a href="#function-signature">Function Signature</a><br />
     5.5 <a href="#getting-it-together">Getting it together</a><br />
</li>
<li><a href="#debugging-and-testing">Debugging and Testing</a><br />
</li>
<li><a href="#notes">Notes</a><br />
</li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>
<h3 id="currying">Currying</h3>
<p>Currying is the process of transformation of a function call like <code>f(a, b, c)</code> to <code>f(a)(b)(c)</code>. A curried function returns a concrete value only when it receives all its arguments! If it does recieve an insufficient amount of arguments, say 1 of 3, it returns a <em>curried function</em>, that returns after receiving 2 arguments.</p>
<pre><code>curry(f(a, b, c)) = h(a)(b)(c)

h(x) = g   &lt;- curried function that takes upto 2 args (g)
g(y) = k   &lt;- curried function that takes upto 1 arg (k)
k(z) = v   &lt;- a value (v)

Keen readers will conclude the following,
h(x)(y)(z) = g(y)(z) = k(z) = v</code></pre>
<p>Mathematically, if <code>f</code> is a function that takes two arguments <code>x</code> and <code>y</code>, such that <code>x ϵ X</code>, and <code>y ϵ Y</code> , we write it as:</p>
<pre><code>f: (X × Y) -&gt; Z</code></pre>
<p>where <code>×</code> denotes the Cartesian product of set <code>X</code> and <code>Y</code>, and curried <code>f</code> (denoted by <code>h</code> here) is written as:</p>
<pre><code>h: X -&gt; (Y -&gt; Z)</code></pre>
<h3 id="procedural-macros">Procedural Macros</h3>
<p>These are functions that take code as input and spit out modified code as output. Powerful stuff. Rust has three kinds of proc-macros:</p>
<ul>
<li>Function like macros<br />
</li>
<li>Derive macros: <code>#[derive(...)]</code>, used to automatically implement traits for structs/enums<br />
</li>
<li>and Attribute macros: <code>#[test]</code>, usually slapped onto functions</li>
</ul>
<p>We will be using Attribute macros to convert a Rust function into a curried Rust function, which we should be able to call via: <code>function(arg1)(arg2)</code>.</p>
<h3 id="definitions">Definitions</h3>
<p>Being respectable programmers, we define the input to and the output from our proc-macro. Here’s a good non-trivial function to start out with:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">fn</span> add(x<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span> z<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="kw">return</span> x <span class="op">+</span> y <span class="op">+</span> z<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Hmm, what would our output look like? What should our proc-macro generate ideally? Well, if we understood currying correctly, we should accept an argument and return a function that accepts an argument and returns … you get the point. Something like this should do:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">fn</span> add_curried1(x<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="op">?</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="kw">fn</span> add_curried2 (y<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="op">?</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    <span class="kw">return</span> <span class="kw">fn</span> add_curried3 (z<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>      <span class="kw">return</span> x <span class="op">+</span> y <span class="op">+</span> z<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>  <span class="op">}</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>A couple of things to note:</p>
<p><strong>Return types</strong><br />
We have placed <code>?</code>s in place of return types. Let’s try to fix that. <code>add_curried3</code> returns the ‘value’, so <code>u32</code> is accurate. <code>add_curried2</code> returns <code>add_curried3</code>. What is the type of <code>add_curried3</code>? It is a function that takes in a <code>u32</code> and returns a <code>u32</code>. So a <code>fn(u32) -&gt; u32</code> will do right? No, I’ll explain why in the next point, but for now, we will make use of the <code>Fn</code> trait, our return type is <code>impl Fn(u32) -&gt; u32</code>. This basically tells the compiler that we will be returning something function-like, a.k.a, behaves like a <code>Fn</code>. Cool!</p>
<p>If you have been following along, you should be able to tell that the return type of <code>add_curried1</code> is:</p>
<pre><code>impl Fn(u32) -&gt; (impl Fn(u32) -&gt; u32)</code></pre>
<p>We can drop the parentheses because <code>-&gt;</code> is right associative:</p>
<pre><code>impl Fn(u32) -&gt; impl Fn(u32) -&gt; u32
</code></pre>
<p><strong>Accessing environment</strong><br />
A function cannot access it’s environment. Our solution will not work. <code>add_curried3</code> attempts to access <code>x</code>, which is not allowed! A closure<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> however, can. If we are returning a closure, our return type must be <code>impl Fn</code>, and not <code>fn</code>. The difference between the <code>Fn</code> trait and function pointers is beyond the scope of this post.</p>
<h3 id="refinement">Refinement</h3>
<p>Armed with knowledge, we refine our expected output, this time, employing closures:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">fn</span> add(x<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  <span class="kw">return</span> <span class="kw">move</span> <span class="op">|</span>y<span class="op">|</span> <span class="kw">move</span> <span class="op">|</span>z<span class="op">|</span> x <span class="op">+</span> y <span class="op">+</span> z<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Alas, that does not compile either! It errors out with the following message:</p>
<pre><code>error[E0562]: `impl Trait` not allowed outside of function
and inherent method return types
  --&gt; src/main.rs:17:37
   |
   | fn add(x: u32) -&gt; impl Fn(u32) -&gt; impl Fn(u32) -&gt; u32
   |                                   ^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>You are allowed to return an <code>impl Fn</code> only inside a function. We are currently returning it from another return! Or at least, that was the most I could make out of the error message.</p>
<p>We are going to have to cheat a bit to fix this issue; with type aliases and a convenient nightly feature <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="at">#![</span>feature<span class="at">(</span>type_alias_impl_trait<span class="at">)]</span>  <span class="co">// allows us to use `impl Fn` in type aliases!</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="kw">type</span> T0 <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span>                 <span class="co">// the return value when zero args are to be applied</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span class="kw">type</span> T1 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> T0<span class="op">;</span>  <span class="co">// the return value when one arg is to be applied</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span class="kw">type</span> T2 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> T1<span class="op">;</span>  <span class="co">// the return value when two args are to be applied</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a><span class="kw">fn</span> add(x<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> T2 <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  <span class="kw">return</span> <span class="kw">move</span> <span class="op">|</span>y<span class="op">|</span> <span class="kw">move</span> <span class="op">|</span>z<span class="op">|</span> x <span class="op">+</span> y <span class="op">+</span> z<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Drop that into a cargo project, call <code>add(4)(5)(6)</code>, cross your fingers, and run <code>cargo +nightly run</code>. You should see a 15 unless you forgot to print it!</p>
<h3 id="the-in-betweens">The In-Betweens</h3>
<p>Let us write the magical bits that take us from function to curried function.</p>
<p>Initialize your workspace with <code>cargo new --lib currying</code>. Proc-macro crates are libraries with exactly one export, the macro itself. Add a <code>tests</code> directory to your crate root. Your directory should look something like this:</p>
<pre><code>.
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── smoke.rs</code></pre>
<h4 id="dependencies">Dependencies</h4>
<p>We will be using a total of 3 external crates:</p>
<ul>
<li><a href="https://docs.rs/proc-macro2/1.0.12/proc_macro2/">proc_macro2</a></li>
<li><a href="https://docs.rs/syn/1.0.18/syn/index.html">syn</a></li>
<li><a href="https://docs.rs/quote/1.0.4/quote/index.html">quote</a></li>
</ul>
<p>Here’s a sample <code>Cargo.toml</code>:</p>
<pre><code># Cargo.toml

[dependencies]
proc-macro2 = &quot;1.0.9&quot;
quote = &quot;1.0&quot;

[dependencies.syn]
version = &quot;1.0&quot;
features = [&quot;full&quot;]

[lib]
proc-macro = true  # this is important!</code></pre>
<p>We will be using an external <code>proc-macro2</code> crate as well as an internal <code>proc-macro</code> crate. Not confusing at all!</p>
<h4 id="the-attribute-macro">The attribute macro</h4>
<p>Drop this into <code>src/lib.rs</code>, to get the ball rolling.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">proc_macro::</span>TokenStream<span class="op">;</span>  <span class="co">// 1</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">quote::</span>quote<span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">syn::</span><span class="op">{</span>parse_macro_input<span class="op">,</span> ItemFn<span class="op">};</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="at">#[</span>proc_macro_attribute<span class="at">]</span>   <span class="co">// 2</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span class="kw">pub</span> <span class="kw">fn</span> curry(_attr<span class="op">:</span> TokenStream<span class="op">,</span> item<span class="op">:</span> TokenStream) <span class="op">-&gt;</span> TokenStream <span class="op">{</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>  <span class="kw">let</span> parsed <span class="op">=</span> <span class="pp">parse_macro_input!</span>(item <span class="kw">as</span> ItemFn)<span class="op">;</span>  <span class="co">// 3</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>  generate_curry(parsed)<span class="op">.</span>into()  <span class="co">// 4</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a><span class="kw">fn</span> generate_curry(parsed<span class="op">:</span> ItemFn) <span class="op">-&gt;</span> <span class="pp">proc_macro2::</span>TokenStream <span class="op">{}</span></span></code></pre></div>
<p><strong>1. Imports</strong></p>
<p>A <code>Tokenstream</code> holds (hopefully valid) Rust code, this is the type of our input and output. Note that we are importing this type from <code>proc_macro</code> and not <code>proc_macro2</code>.</p>
<p><code>quote!</code> from the <code>quote</code> crate is a macro that allows us to quickly produce <code>TokenStream</code>s. Much like the LISP <code>quote</code> procedure, you can use the <code>quote!</code> macro for symbolic transformations.</p>
<p><code>ItemFn</code> from the <code>syn</code> crate holds the parsed <code>TokenStream</code> of a Rust function. <code>parse_macro_input!</code> is a helper macro provided by <code>syn</code>.</p>
<p><strong>2. The lone export</strong></p>
<p>Annotate the only <code>pub</code> of our crate with <code>#[proc_macro_attribute]</code>. This tells rustc that <code>curry</code> is a procedural macro, and allows us to use it as <code>#[crate_name::curry]</code> in other crates. Note the signature of the <code>curry</code> function. <code>_attr</code> is the <code>TokenStream</code> representing the attribute itself, <code>item</code> refers to the thing we slapped our macro into, in this case a function (like <code>add</code>). The return value is a modified <code>TokenStream</code>, this will contain our curried version of <code>add</code>.</p>
<p><strong>3. The helper macro</strong></p>
<p>A <code>TokenStream</code> is a little hard to work with, which is why we have the <code>syn</code> crate, which provides types to represent Rust tokens. An <code>RArrow</code> struct to represent the return arrow on a function and so on. One of those types is <code>ItemFn</code>, that represents an entire Rust function. The <code>parse_macro_input!</code> automatically puts the input to our macro into an <code>ItemFn</code>. What a gentleman!</p>
<p><strong>4. Returning <code>TokenStream</code>s </strong></p>
<p>We haven’t filled in <code>generate_curry</code> yet, but we can see that it returns a <code>proc_macro2::TokenStream</code> and not a <code>proc_macro::TokenStream</code>, so drop a <code>.into()</code> to convert it.</p>
<p>Lets move on, and fill in <code>generate_curry</code>, I would suggest keeping the documentation for <a href="https://docs.rs/syn/1.0.19/syn/struct.ItemFn.html"><code>syn::ItemFn</code></a> and <a href="https://docs.rs/syn/1.0.19/syn/struct.Signature.html"><code>syn::Signature</code></a> open.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="kw">fn</span> generate_curry(parsed<span class="op">:</span> ItemFn) <span class="op">-&gt;</span> <span class="pp">proc_macro2::</span>TokenStream <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  <span class="kw">let</span> fn_body <span class="op">=</span> parsed<span class="op">.</span>block<span class="op">;</span>      <span class="co">// function body</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>  <span class="kw">let</span> sig <span class="op">=</span> parsed<span class="op">.</span>sig<span class="op">;</span>            <span class="co">// function signature</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>  <span class="kw">let</span> vis <span class="op">=</span> parsed<span class="op">.</span>vis<span class="op">;</span>            <span class="co">// visibility, pub or not</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>  <span class="kw">let</span> fn_name <span class="op">=</span> sig<span class="op">.</span>ident<span class="op">;</span>         <span class="co">// function name/identifier</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>  <span class="kw">let</span> fn_args <span class="op">=</span> sig<span class="op">.</span>inputs<span class="op">;</span>        <span class="co">// comma separated args</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>  <span class="kw">let</span> fn_return_type <span class="op">=</span> sig<span class="op">.</span>output<span class="op">;</span> <span class="co">// return type</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>We are simply extracting the bits of the function, we will be reusing the original function’s visibility and name. Take a look at what <code>syn::Signature</code> can tell us about a function:</p>
<pre><code>                       .-- syn::Ident (ident)
                      /
                 fn add(x: u32, y: u32) -&gt; u32
  (fn_token)      /     ~~~~~~~,~~~~~~  ~~~~~~
syn::token::Fn --&#39;            /               \       (output)
                             &#39;                 `- syn::ReturnType
             Punctuated&lt;FnArg, Comma&gt; (inputs)</code></pre>
<p>Enough analysis, lets produce our first bit of Rust code.</p>
<h4 id="function-body">Function Body</h4>
<p>Recall that the body of a curried <code>add</code> should look like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">return</span> <span class="kw">move</span> <span class="op">|</span>y<span class="op">|</span> <span class="kw">move</span> <span class="op">|</span>z<span class="op">|</span> x <span class="op">+</span> y <span class="op">+</span> z<span class="op">;</span></span></code></pre></div>
<p>And in general:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">return</span> <span class="kw">move</span> <span class="op">|</span>arg2<span class="op">|</span> <span class="kw">move</span> <span class="op">|</span>arg3<span class="op">|</span> <span class="op">...</span> <span class="op">|</span>argN<span class="op">|</span> <span class="op">&lt;</span>function body here<span class="op">&gt;</span></span></code></pre></div>
<p>We already have the function’s body, provided by <code>fn_body</code>, in our <code>generate_curry</code> function. All that’s left to add is the <code>move |arg2| move |arg3| ...</code> stuff, for which we need to extract the argument identifiers (doc: <a href="https://docs.rs/syn/1.0.18/syn/punctuated/struct.Punctuated.html">Punctuated</a>, <a href="https://docs.rs/syn/1.0.18/syn/enum.FnArg.html">FnArg</a>, <a href="https://docs.rs/syn/1.0.18/syn/struct.PatType.html">PatType</a>):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">syn::punctuated::</span>Punctuated<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">syn::</span><span class="op">{</span>parse_macro_input<span class="op">,</span> FnArg<span class="op">,</span> Pat<span class="op">,</span> ItemFn<span class="op">,</span> Block<span class="op">};</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a><span class="kw">fn</span> extract_arg_idents(fn_args<span class="op">:</span> Punctuated<span class="op">&lt;</span>FnArg<span class="op">,</span> <span class="pp">syn::token::</span>Comma<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">Box</span><span class="op">&lt;</span>Pat<span class="op">&gt;&gt;</span> <span class="op">{</span> </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>  <span class="kw">return</span> fn_args<span class="op">.</span>into_iter()<span class="op">.</span>map(extract_arg_pat)<span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>()<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Alright, so we are iterating over function args (<code>Punctuated</code> is a collection that you can iterate over) and mapping an <code>extract_arg_pat</code> to every item. What’s <code>extract_arg_pat</code>?</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="kw">fn</span> extract_arg_pat(a<span class="op">:</span> FnArg) <span class="op">-&gt;</span> <span class="dt">Box</span><span class="op">&lt;</span>Pat<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  <span class="kw">match</span> a <span class="op">{</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>    <span class="pp">FnArg::</span>Typed(p) <span class="op">=&gt;</span> p<span class="op">.</span>pat<span class="op">,</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>    _ <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">&quot;Not supported on types with `self`!&quot;</span>)<span class="op">,</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  <span class="op">}</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p><code>FnArg</code> is an enum type as you might have guessed. The <code>Typed</code> variant encompasses args that are written as <code>name: type</code> and the other variant, <code>Reciever</code> refers to <code>self</code> types. Ignore those for now, keep it simple.</p>
<p>Every <code>FnArg::Typed</code> value contains a <code>pat</code>, which is in essence, the name of the argument. The type of the arg is accessible via <code>p.ty</code> (we will be using this later).</p>
<p>With that done, we should be able to write the codegen for the function body:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="kw">fn</span> generate_body(fn_args<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">Box</span><span class="op">&lt;</span>Pat<span class="op">&gt;</span>]<span class="op">,</span> body<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span>Block<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="pp">proc_macro2::</span>TokenStream <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  <span class="pp">quote!</span> <span class="op">{</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    <span class="kw">return</span> #( <span class="kw">move</span> <span class="op">|</span>#fn_args<span class="op">|</span>  )<span class="op">*</span> #body</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>  <span class="op">}</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>That is some scary looking syntax! Allow me to explain. The <code>quote!{ ... }</code> returns a <code>proc_macro2::TokenStream</code>, if we wrote <code>quote!{ let x = 1 + 2; }</code>, it wouldn’t create a new variable <code>x</code> with value 3, it would literally produce a stream of tokens with that expression.</p>
<p>The <code>#</code> enables variable interpolation. <code>#body</code> will look for <code>body</code> in the current scope, take its value, and insert it in the returned <code>TokenStream</code>. Kinda like quasi quoting in LISPs, you have written one.</p>
<p>What about <code>#( move |#fn_args| )*</code>? That is repetition. <code>quote</code> iterates through <code>fn_args</code>, and drops a <code>move</code> behind each one, it then places pipes (<code>|</code>), around it.</p>
<p>Let us test our first bit of codegen! Modify <code>generate_curry</code> like so:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a> <span class="kw">fn</span> generate_curry(parsed<span class="op">:</span> ItemFn) <span class="op">-&gt;</span> TokenStream <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>   <span class="kw">let</span> fn_body <span class="op">=</span> parsed<span class="op">.</span>block<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>   <span class="kw">let</span> sig <span class="op">=</span> parsed<span class="op">.</span>sig<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>   <span class="kw">let</span> vis <span class="op">=</span> parsed<span class="op">.</span>vis<span class="op">;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>   <span class="kw">let</span> fn_name <span class="op">=</span> sig<span class="op">.</span>ident<span class="op">;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>   <span class="kw">let</span> fn_args <span class="op">=</span> sig<span class="op">.</span>inputs<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>   <span class="kw">let</span> fn_return_type <span class="op">=</span> sig<span class="op">.</span>output<span class="op">;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a><span class="op">+</span>  <span class="kw">let</span> arg_idents <span class="op">=</span> extract_arg_idents(fn_args<span class="op">.</span>clone())<span class="op">;</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a><span class="op">+</span>  <span class="kw">let</span> first_ident <span class="op">=</span> <span class="op">&amp;</span>arg_idents<span class="op">.</span>first()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a><span class="op">+</span>  <span class="co">// remember, our curried body starts with the second argument!</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a><span class="op">+</span>  <span class="kw">let</span> curried_body <span class="op">=</span> generate_body(<span class="op">&amp;</span>arg_idents[<span class="dv">1</span><span class="op">..</span>]<span class="op">,</span> fn_body<span class="op">.</span>clone())<span class="op">;</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true"></a><span class="op">+</span>  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> curried_body)<span class="op">;</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true"></a>   <span class="kw">return</span> <span class="pp">TokenStream::</span>new()<span class="op">;</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true"></a> <span class="op">}</span></span></code></pre></div>
<p>Add a little test to <code>tests/</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="co">// tests/smoke.rs</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span class="at">#[</span><span class="pp">currying::</span>curry<span class="at">]</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a><span class="kw">fn</span> add(x<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span> z<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>  x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="kw">fn</span> works() <span class="op">{</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>  <span class="pp">assert!</span>(<span class="cn">true</span>)<span class="op">;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>You should find something like this in the output of <code>cargo test</code>:</p>
<pre><code>return move | y | move | z | { x + y + z }</code></pre>
<p>Glorious <code>println!</code> debugging!</p>
<h4 id="function-signature">Function signature</h4>
<p>This section gets into the more complicated bits of the macro, generating type aliases and the function signature. By the end of this section, we should have a full working auto-currying macro!</p>
<p>Recall what our generated type aliases should look like, for our <code>add</code> function:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">type</span> T0 <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="kw">type</span> T1 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> T0<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="kw">type</span> T2 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> T1<span class="op">;</span></span></code></pre></div>
<p>In general:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">type</span> T0 <span class="op">=</span> <span class="op">&lt;</span><span class="kw">return</span> <span class="kw">type</span>&gt;<span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a><span class="kw">type</span> T1 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="op">&lt;</span><span class="kw">type</span> of arg N&gt;) -&gt; T0<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="kw">type</span> T2 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="op">&lt;</span><span class="kw">type</span> of arg N - 1&gt;) -&gt; T1<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="op">.</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a><span class="op">.</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a><span class="op">.</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a><span class="kw">type</span> T(N-1) <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="op">&lt;</span><span class="kw">type</span> of arg 2&gt;) -&gt; T(N-2)<span class="op">;</span></span></code></pre></div>
<p>To codegen that, we need the types of:</p>
<ul>
<li>all our inputs (arguments)</li>
<li>the output (the return type)</li>
</ul>
<p>To fetch the types of all our inputs, we can simply reuse the bits we wrote to fetch the names of all our inputs! (doc: <a href="https://docs.rs/syn/1.0.18/syn/enum.Type.html">Type</a>)</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">syn::</span><span class="op">{</span>parse_macro_input<span class="op">,</span> Block<span class="op">,</span> FnArg<span class="op">,</span> ItemFn<span class="op">,</span> Pat<span class="op">,</span> ReturnType<span class="op">,</span> Type<span class="op">};</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a><span class="kw">fn</span> extract_type(a<span class="op">:</span> FnArg) <span class="op">-&gt;</span> <span class="dt">Box</span><span class="op">&lt;</span>Type<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>  <span class="kw">match</span> a <span class="op">{</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>    <span class="pp">FnArg::</span>Typed(p) <span class="op">=&gt;</span> p<span class="op">.</span>ty<span class="op">,</span>  <span class="co">// notice `ty` instead of `pat`</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>      _ <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">&quot;Not supported on types with `self`!&quot;</span>)<span class="op">,</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>  <span class="op">}</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a><span class="kw">fn</span> extract_arg_types(fn_args<span class="op">:</span> Punctuated<span class="op">&lt;</span>FnArg<span class="op">,</span> <span class="pp">syn::token::</span>Comma<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">Box</span><span class="op">&lt;</span>Type<span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a>  <span class="kw">return</span> fn_args<span class="op">.</span>into_iter()<span class="op">.</span>map(extract_type)<span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>()<span class="op">;</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>A good reader would have looked at the docs for output member of the <code>syn::Signature</code> struct. It has the type <code>syn::ReturnType</code>. So there is no extraction to do here right? There are actually a couple of things we have to ensure here:</p>
<ol type="1">
<li><p>We need to ensure that the function returns! A function that does not return is pointless in this case, and I will tell you why, in the <a href="#notes">Notes</a> section.</p></li>
<li><p>A <code>ReturnType</code> encloses the arrow of the return as well, we need to get rid of that. Recall:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">type</span> T0 <span class="op">=</span> <span class="dt">u32</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="co">// and not</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a><span class="kw">type</span> T0 <span class="op">=</span> <span class="op">-&gt;</span> <span class="dt">u32</span></span></code></pre></div></li>
</ol>
<p>Here is the snippet that handles extraction of the return type (doc: <a href="https://docs.rs/syn/1.0.19/syn/enum.ReturnType.html">syn::ReturnType</a>):</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a><span class="kw">fn</span> extract_return_type(a<span class="op">:</span> ReturnType) <span class="op">-&gt;</span> <span class="dt">Box</span><span class="op">&lt;</span>Type<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>  <span class="kw">match</span> a <span class="op">{</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    <span class="pp">ReturnType::</span>Type(_<span class="op">,</span> p) <span class="op">=&gt;</span> p<span class="op">,</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>    _ <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">&quot;Not supported on functions without return types!&quot;</span>)<span class="op">,</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>  <span class="op">}</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>You might notice that we are making extensive use of the <code>panic!</code> macro. Well, that is because it is a good idea to quit on receiving an unsatisfactory <code>TokenStream</code>.</p>
<p>With all our types ready, we can get on with generating type aliases:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a><span class="kw">use</span> <span class="pp">quote::</span><span class="op">{</span>quote<span class="op">,</span> format_ident<span class="op">};</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a><span class="kw">fn</span> generate_type_aliases(</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>  fn_arg_types<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">Box</span><span class="op">&lt;</span>Type<span class="op">&gt;</span>]<span class="op">,</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>  fn_return_type<span class="op">:</span> <span class="dt">Box</span><span class="op">&lt;</span>Type<span class="op">&gt;,</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>  fn_name<span class="op">:</span> <span class="op">&amp;</span><span class="pp">syn::</span>Ident<span class="op">,</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="pp">proc_macro2::</span>TokenStream<span class="op">&gt;</span> <span class="op">{</span>    <span class="co">// 1</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a>  <span class="kw">let</span> type_t0 <span class="op">=</span> <span class="pp">format_ident!</span>(<span class="st">&quot;_{}_T0&quot;</span><span class="op">,</span> fn_name)<span class="op">;</span>    <span class="co">// 2</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true"></a>  <span class="kw">let</span> <span class="kw">mut</span> type_aliases <span class="op">=</span> <span class="pp">vec!</span>[<span class="pp">quote!</span> <span class="op">{</span> <span class="kw">type</span> #type_t0 <span class="op">=</span> #fn_return_type  <span class="op">}</span>]<span class="op">;</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true"></a></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true"></a>  <span class="co">// 3</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true"></a>  <span class="kw">for</span> (i<span class="op">,</span> t) <span class="kw">in</span> (<span class="dv">1</span><span class="op">..</span>)<span class="op">.</span>zip(fn_arg_types<span class="op">.</span>into_iter()<span class="op">.</span>rev()) <span class="op">{</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true"></a>    <span class="kw">let</span> p <span class="op">=</span> <span class="pp">format_ident!</span>(<span class="st">&quot;_{}_{}&quot;</span><span class="op">,</span> fn_name<span class="op">,</span> <span class="pp">format!</span>(<span class="st">&quot;T{}&quot;</span><span class="op">,</span> i <span class="op">-</span> <span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true"></a>    <span class="kw">let</span> n <span class="op">=</span> <span class="pp">format_ident!</span>(<span class="st">&quot;_{}_{}&quot;</span><span class="op">,</span> fn_name<span class="op">,</span> <span class="pp">format!</span>(<span class="st">&quot;T{}&quot;</span><span class="op">,</span> i))<span class="op">;</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true"></a>    type_aliases<span class="op">.</span>push(<span class="pp">quote!</span> <span class="op">{</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true"></a>        <span class="kw">type</span> #n <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(#t) <span class="op">-&gt;</span> #p</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true"></a>  <span class="op">}</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true"></a></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true"></a>  <span class="kw">return</span> type_aliases<span class="op">;</span></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p><strong>1. The return value</strong><br />
We are returning a <code>Vec&lt;proc_macro2::TokenStream&gt;</code>, i. e., a list of <code>TokenStream</code>s, where each item is a type alias.</p>
<p><strong>2. Format identifier?</strong><br />
I’ve got some explanation to do on this line. Clearly, we are trying to write the first type alias, and initialize our <code>TokenStream</code> vector with <code>T0</code>, because it is different from the others:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="kw">type</span> T0 <span class="op">=</span> something</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a><span class="co">// the others are of the form</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a><span class="kw">type</span> Tr <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(something) <span class="op">-&gt;</span> something</span></code></pre></div>
<p><code>format_ident!</code> is similar to <code>format!</code>. Instead of returning a formatted string, it returns a <code>syn::Ident</code>. Therefore, <code>type_t0</code> is actually an identifier for, in the case of our <code>add</code> function, <code>_add_T0</code>. Why is this formatting important? Namespacing.</p>
<p>Picture this, we have two functions, <code>add</code> and <code>subtract</code>, that we wish to curry with our macro:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="at">#[</span>curry<span class="at">]</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span class="kw">fn</span> add(<span class="op">...</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a><span class="at">#[</span>curry<span class="at">]</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a><span class="kw">fn</span> sub(<span class="op">...</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>Here is the same but with macros expanded:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="kw">type</span> T0 <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a><span class="kw">type</span> T1 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> T0<span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a><span class="kw">fn</span> add( <span class="op">...</span> ) <span class="op">-&gt;</span> T1 <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a><span class="kw">type</span> T0 <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a><span class="kw">type</span> T1 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> T0<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true"></a><span class="kw">fn</span> sub( <span class="op">...</span> ) <span class="op">-&gt;</span> T1 <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>We end up with two definitions of <code>T0</code>! Now, if we do the little <code>format_ident!</code> dance we did up there:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="kw">type</span> _add_T0 <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a><span class="kw">type</span> _add_T1 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> _add_T0<span class="op">;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a><span class="kw">fn</span> add( <span class="op">...</span> ) <span class="op">-&gt;</span> _add_T1 <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a><span class="kw">type</span> _sub_T0 <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a><span class="kw">type</span> _sub_T1 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> _sub_T0<span class="op">;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a><span class="kw">fn</span> sub( <span class="op">...</span> ) <span class="op">-&gt;</span> _sub_T1 <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<p>Voilà! The type aliases don’t tread on each other. Remember to import <code>format_ident</code> from the <code>quote</code> crate.</p>
<p><strong>3. The TokenStream Vector</strong></p>
<p>We iterate over our types in reverse order (<code>T0</code> is the last return, <code>T1</code> is the second last, so on), assign a number to each iteration with <code>zip</code>, generate type names with <code>format_ident</code>, push a <code>TokenStream</code> with the help of <code>quote</code> and variable interpolation.</p>
<p>If you are wondering why we used <code>(1..).zip()</code> instead of <code>.enumerate()</code>, it’s because we wanted to start counting from 1 instead of 0 (we are already done with <code>T0</code>!).</p>
<h4 id="getting-it-together">Getting it together</h4>
<p>I promised we’d have a fully working macro by the end of last section. I lied, we have to tie everything together in our <code>generate_curry</code> function:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="co">// src/lib.rs</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a> <span class="kw">fn</span> generate_curry(parsed<span class="op">:</span> ItemFn) <span class="op">-&gt;</span> <span class="pp">proc_macro2::</span>TokenStream <span class="op">{</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>   <span class="kw">let</span> fn_body <span class="op">=</span> parsed<span class="op">.</span>block<span class="op">;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>   <span class="kw">let</span> sig <span class="op">=</span> parsed<span class="op">.</span>sig<span class="op">;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>   <span class="kw">let</span> vis <span class="op">=</span> parsed<span class="op">.</span>vis<span class="op">;</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>   <span class="kw">let</span> fn_name <span class="op">=</span> sig<span class="op">.</span>ident<span class="op">;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>   <span class="kw">let</span> fn_args <span class="op">=</span> sig<span class="op">.</span>inputs<span class="op">;</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a>   <span class="kw">let</span> fn_return_type <span class="op">=</span> sig<span class="op">.</span>output<span class="op">;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true"></a>   <span class="kw">let</span> arg_idents <span class="op">=</span> extract_arg_idents(fn_args<span class="op">.</span>clone())<span class="op">;</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true"></a>   <span class="kw">let</span> first_ident <span class="op">=</span> <span class="op">&amp;</span>arg_idents<span class="op">.</span>first()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true"></a>   <span class="kw">let</span> curried_body <span class="op">=</span> generate_body(<span class="op">&amp;</span>arg_idents[<span class="dv">1</span><span class="op">..</span>]<span class="op">,</span> fn_body<span class="op">.</span>clone())<span class="op">;</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true"></a></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true"></a><span class="op">+</span>  <span class="kw">let</span> arg_types <span class="op">=</span> extract_arg_types(fn_args<span class="op">.</span>clone())<span class="op">;</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true"></a><span class="op">+</span>  <span class="kw">let</span> first_type <span class="op">=</span> <span class="op">&amp;</span>arg_types<span class="op">.</span>first()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true"></a><span class="op">+</span>  <span class="kw">let</span> type_aliases <span class="op">=</span> generate_type_aliases(</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true"></a><span class="op">+</span>      <span class="op">&amp;</span>arg_types[<span class="dv">1</span><span class="op">..</span>]<span class="op">,</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true"></a><span class="op">+</span>      extract_return_type(fn_return_type)<span class="op">,</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true"></a><span class="op">+</span>      <span class="op">&amp;</span>fn_name<span class="op">,</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true"></a><span class="op">+</span>  )<span class="op">;</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true"></a></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true"></a><span class="op">+</span>  <span class="kw">let</span> return_type <span class="op">=</span> <span class="pp">format_ident!</span>(<span class="st">&quot;_{}_{}&quot;</span><span class="op">,</span> <span class="op">&amp;</span>fn_name<span class="op">,</span> <span class="pp">format!</span>(<span class="st">&quot;T{}&quot;</span><span class="op">,</span> type_aliases<span class="op">.</span>len() <span class="op">-</span> <span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true"></a><span class="op">+</span>  <span class="kw">return</span> <span class="pp">quote!</span> <span class="op">{</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true"></a><span class="op">+</span>      #(#type_aliases)<span class="op">;*</span> <span class="op">;</span></span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true"></a><span class="op">+</span>      #vis <span class="kw">fn</span> #fn_name (#first_ident<span class="op">:</span> #first_type) <span class="op">-&gt;</span> #return_type <span class="op">{</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true"></a><span class="op">+</span>          #curried_body <span class="op">;</span></span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true"></a><span class="op">+</span>      <span class="op">}</span></span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true"></a><span class="op">+</span>  <span class="op">};</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true"></a> <span class="op">}</span></span></code></pre></div>
<p>Most of the additions are self explanatory, I’ll go through the return statement with you. We are returning a <code>quote!{ ... }</code>, so a <code>proc_macro2::TokenStream</code>. We are iterating through the <code>type_aliases</code> variable, which you might recall, is a <code>Vec&lt;TokenStream&gt;</code>. You might notice the sneaky semicolon before the <code>*</code>. This basically tells <code>quote</code>, to insert an item, then a semicolon, and then the next one, another semicolon, and so on. The semicolon is a separator. We need to manually insert another semicolon at the end of it all, <code>quote</code> doesn’t insert a separator at the end of the iteration.</p>
<p>We retain the visibility and name of our original function. Our curried function takes as args, just the first argument of our original function. The return type of our curried function is actually, the last type alias we create. If you think back to our manually curried <code>add</code> function, we returned <code>T2</code>, which was in fact, the last type alias we created.</p>
<p>I am sure, at this point, you are itching to test this out, but before that, let me introduce you to some good methods of debugging proc-macro code.</p>
<h3 id="debugging-and-testing">Debugging and Testing</h3>
<p>Install <code>cargo-expand</code> via:</p>
<pre><code>cargo install cargo-expand</code></pre>
<p><code>cargo-expand</code> is a neat little tool that expands your macro in places where it is used, and lets you view the generated code! For example:</p>
<pre class="shell"><code># create a bin package hello
$ cargo new hello

# view the expansion of the println! macro
$ cargo expand

#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
fn main() {
  {
    ::std::io::_print(::core::fmt::Arguments::new_v1(
        &amp;[&quot;Hello, world!\n&quot;],
        &amp;match () {
            () =&gt; [],
        },
      ));
  };
}</code></pre>
<p>Writing proc-macros without <code>cargo-expand</code> is tantamount to driving a vehicle without rear view mirrors! Keep an eye on what is going on behind your back.</p>
<p>Now, your macro won’t always compile, you might just recieve the bee movie script as an error. <code>cargo-expand</code> will not work in such cases. I would suggest printing out your variables to inspect them. <code>TokenStream</code> implements <code>Display</code> as well as <code>Debug</code>. We don’t always have to be respectable programmers. Just print it.</p>
<p>Enough of that, lets get testing:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="co">// tests/smoke.rs</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a><span class="at">#![</span>feature<span class="at">(</span>type_alias_impl_trait<span class="at">)]</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a><span class="at">#[</span><span class="pp">crate_name::</span>curry<span class="at">]</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a><span class="kw">fn</span> add(x<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span> z<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a>   x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true"></a><span class="kw">fn</span> works() <span class="op">{</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true"></a>  <span class="pp">assert_eq!</span>(<span class="dv">15</span><span class="op">,</span> add(<span class="dv">4</span>)(<span class="dv">5</span>)(<span class="dv">6</span>))<span class="op">;</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Run <code>cargo +nightly test</code>. You should see a pleasing message:</p>
<pre><code>running 1 test
test tests::works ... ok</code></pre>
<p>Take a look at the expansion for our curry macro, via <code>cargo +nightly expand --tests smoke</code>:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="kw">type</span> _add_T0 <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a><span class="kw">type</span> _add_T1 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> _add_T0<span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a><span class="kw">type</span> _add_T2 <span class="op">=</span> <span class="kw">impl</span> <span class="bu">Fn</span>(<span class="dt">u32</span>) <span class="op">-&gt;</span> _add_T1<span class="op">;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a><span class="kw">fn</span> add(x<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> _add_T2 <span class="op">{</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>  <span class="kw">return</span> (<span class="kw">move</span> <span class="op">|</span>y<span class="op">|</span> <span class="op">{</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>    <span class="kw">move</span> <span class="op">|</span>z<span class="op">|</span> <span class="op">{</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true"></a>      <span class="kw">return</span> x <span class="op">+</span> y <span class="op">+</span> z<span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true"></a>  <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true"></a><span class="co">// a bunch of other stuff generated by #[test] and assert_eq!</span></span></code></pre></div>
<p>A sight for sore eyes.</p>
<p>Here is a more complex example that generates ten multiples of the first ten natural numbers:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span class="at">#[</span>curry<span class="at">]</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a><span class="kw">fn</span> product(x<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>  x <span class="op">*</span> y</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a><span class="kw">fn</span> multiples() <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">u32</span><span class="op">&gt;&gt;{</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a>  <span class="kw">let</span> v <span class="op">=</span> (<span class="dv">1</span><span class="op">..=</span><span class="dv">10</span>)<span class="op">.</span>map(product)<span class="op">;</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true"></a>  <span class="kw">return</span> (<span class="dv">1</span><span class="op">..=</span><span class="dv">10</span>)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true"></a>      <span class="op">.</span>map(<span class="op">|</span>x<span class="op">|</span> v<span class="op">.</span>clone()<span class="op">.</span>map(<span class="op">|</span>f<span class="op">|</span> f(x))<span class="op">.</span>collect())</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true"></a>      <span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<h3 id="notes">Notes</h3>
<p>I didn’t quite explain why we use <code>move |arg|</code> in our closure. This is because we want to take ownership of the variable supplied to us. Take a look at this example:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span class="kw">let</span> v <span class="op">=</span> add(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a><span class="kw">let</span> g<span class="op">;</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a><span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a>  <span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>  g <span class="op">=</span> v(x)<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> g(<span class="dv">2</span>))<span class="op">;</span></span></code></pre></div>
<p>Variable <code>x</code> goes out of scope before <code>g</code> can return a concrete value. If we take ownership of <code>x</code> by <code>move</code>ing it into our closure, we can expect this to work reliably. In fact, rustc understands this, and forces you to use <code>move</code>.</p>
<p>This usage of <code>move</code> is exactly why <strong>a curried function without a return is useless</strong>. Every variable we pass to our curried function gets moved into its local scope. Playing with these variables cannot cause a change outside this scope. Returning is our only method of interaction with anything beyond this function.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Currying may not seem to be all that useful. Curried functions are unwieldy in Rust because the standard library is not built around currying. If you enjoy the possibilities posed by currying, consider taking a look at Haskell or Scheme.</p>
<p>My original intention with <a href="https://peppe.rs">peppe.rs</a> was to post condensed articles, a micro blog, but this one turned out extra long.</p>
<p>Perhaps I should call it a ‘macro’ blog :)</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://doc.rust-lang.org/book/ch13-01-closures.html">https://doc.rust-lang.org/book/ch13-01-closures.html</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://caniuse.rs">caniuse.rs</a> contains an indexed list of features and their status.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></description>
<link>https://peppe.rs/posts/auto-currying_rust_functions/</link>
<pubDate>Sat, 09 May 2020 06:12:00 +0000</pubDate>
<guid>https://peppe.rs/posts/auto-currying_rust_functions/</guid>
</item>
<item>
<title>Pixel Art In GIMP</title>
<description><p>I’ve always been an admirer of pixel art, because of it’s simplicity and it’s resemblance to bitmap font design. Recently, I decided to take the dive and make some art of my own.</p>
<p>I used GIMP because I am fairly familiar with it. Aseprite seems to be the editor of choice for animated pixel art though.</p>
<h3 id="setting-up-the-canvas">Setting up the canvas</h3>
<p>Picking a canvas size is daunting. Too small, and you won’t be able to fit in enough detail to make a legible piece. Too big and you’ve got too many pixels to work with!</p>
<p>I would suggest starting out with anywhere between 100x100 and 200x200. <a href="https://u.peppe.rs/u9.png">Here’s</a> a sample configuration.</p>
<p>Sometimes I use a 10x10 grid, <code>View &gt; Show Grid</code> and <code>Edit &gt; Preferences &gt; Default Grid &gt; Spacing</code>, but that can get jarring, so I throw down a couple of guides, drag right or down from the left or top gutters for vertical and horizontal guides respectively.</p>
<h3 id="choosing-a-brush">Choosing a Brush</h3>
<p>The most important part of our setup is the brush. Use the Pencil Tool (<code>n</code> on the keyboard) for hard edge drawings. Here’s a small comparison if you don’t know the difference between a hard edge and a soft edge:</p>
<figure>
<img src="https://u.peppe.rs/kz.png" alt="" /><figcaption>Hard edge vs Soft Edge</figcaption>
</figure>
<p>I turn the size down all the way to 1 (<code>[</code> on the keyboard). Set <code>Dynamics</code> off. <a href="https://u.peppe.rs/Fs.png">Here’s</a> a sample brush configuration.</p>
<h3 id="laying-down-the-pixels">Laying down the pixels!</h3>
<p>With the boring stuff out of the way, we can start with our piece. I usually follow a three step process:</p>
<ul>
<li>draw a rough outline</li>
<li>fill in the shadows</li>
<li>add highlights</li>
</ul>
<p>But this process is better explained with an example: an onigiri. Let us start off with a 100x100 canvas.</p>
<h4 id="drawing-the-outline">Drawing the outline</h4>
<p>For the most part, our figure will be symmetric. If you are on GIMP 2.10+, you can take advantage of the Symmetry Painting feature. Go ahead and enable vertical symmetry, <code>Window &gt; Dockable Dialogs &gt; Symmetry Painting</code> and <code>Symmetry Painting &gt; Symmetry &gt; Mirror &gt; Vertical</code>.</p>
<p>If you are running an older version of GIMP, draw in the left side, duplicate the layer, flip it horizontally, and merge it with the original.</p>
<p>Your outline might look something like this:</p>
<p><img src="https://u.peppe.rs/mn.png" /></p>
<p>Go ahead and fill it in with the fill tool (<code>Shift + b</code> on the keyboard), add in some seaweed as well, preferably on a different layer. You can toggle symmetry on and off to save yourself some time.</p>
<p><img src="https://u.peppe.rs/xu.png" /></p>
<h4 id="shadows">Shadows</h4>
<p>For now, let us focus on the shadows on the object itself, we’ll come back to the shadows cast by the object on the surface later.</p>
<p>Shadows on any surface always follow the shape of the surface. A spherical onigiri would have a circular shadow:</p>
<p><img src="https://u.peppe.rs/FU.png" /></p>
<p>A couple of noticeable changes:</p>
<p><strong>Layers</strong>: The layer containing the seaweed has been hidden.<br />
<strong>Color</strong>: The color of the shadow is just a slightly lighter version of the original object (reduce the Value on the HSV scale).<br />
<strong>Area</strong>: The shadow does not go all the way (notice the bottom edges).</p>
<p>The shadow does not go all the way because we will be filling in that area with another, darker shadow! An image might explain better:</p>
<p><img src="https://u.peppe.rs/Br.png" /></p>
<p>To emulate soft lights, reduce the value by 2 to 3 points every iteration. Notice how area <code>1</code> is much larger than area <code>4</code>. This is because an onigiri resembles a bottom heavy oblate spheroid, a sphere that is slightly fatter around the lower bottom, and areas <code>1</code> and <code>2</code> catch more light than areas <code>3</code> and <code>4</code>.</p>
<p>Do the same with the seaweed. The seaweed, being a smaller, flatter object, doesn’t cast much of a shadow, so stop with 1 or 2 iterations of the gradient:</p>
<p><img src="https://u.peppe.rs/T3.png" /></p>
<p>We’re getting there!</p>
<h4 id="highlights">Highlights</h4>
<p>This step handles the details on the strongly illuminated portions of the object. Seaweed is a bit glossy, lighten the edges to make it seem shiny. The rice is not as shiny, but it does form an uneven surface. Add in some shadows to promote the idea of rice grains. Here is the finished result:</p>
<p><img src="https://u.peppe.rs/VE.png" /></p>
<h3 id="finishing-touches">Finishing Touches</h3>
<p>Some color correction and <code>a e s t h e t i c</code> Japanese text later, our piece is complete!</p>
<p><img src="https://u.peppe.rs/cn.png" /></p>
<p>Hold on, why is it so tiny? Well, that’s because our canvas was 100x100, head over to <code>Image &gt; Scale Image</code>, set <code>Quality &gt; Interpolation</code> to <code>None</code> and scale it up to 700x700, et voilà!</p>
<p><img src="https://u.peppe.rs/CH.png" /></p></description>
<link>https://peppe.rs/posts/pixel_art_in_GIMP/</link>
<pubDate>Thu, 09 Apr 2020 16:28:00 +0000</pubDate>
<guid>https://peppe.rs/posts/pixel_art_in_GIMP/</guid>
</item>
<item>
<title>Rapid Refactoring With Vim</title>
<description><p>Last weekend, I was tasked with refactoring the 96 unit tests on <a href="https://github.com/ruma/ruma-events/pull/70">ruma-events</a> to use strictly typed json objects using <code>serde_json::json!</code> instead of raw strings. It was rather painless thanks to vim :)</p>
<p>Here’s a small sample of what had to be done (note the lines prefixed with the arrow):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>→ <span class="kw">use</span> <span class="pp">serde_json::</span><span class="op">{</span>from_str<span class="op">};</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="kw">fn</span> deserialize() <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="pp">assert_eq!</span>(</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>→       <span class="pp">from_str::</span><span class="op">&lt;</span>Action<span class="op">&gt;</span>(<span class="st">r#&quot;{&quot;set_tweak&quot;: &quot;highlight&quot;}&quot;#),</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="st">        Action::SetTweak(Tweak::Highlight { value: true })</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="st">        );</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a><span class="st">  }</span></span></code></pre></div>
<p>had to be converted to:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>→ <span class="kw">use</span> <span class="pp">serde_json::</span><span class="op">{</span>from_value<span class="op">};</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="kw">fn</span> deserialize() <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="pp">assert_eq!</span>(</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>→       <span class="pp">from_value::</span><span class="op">&lt;</span>Action<span class="op">&gt;</span>(<span class="pp">json!</span>(<span class="op">{</span><span class="st">&quot;set_tweak&quot;</span><span class="op">:</span> <span class="st">&quot;highlight&quot;</span><span class="op">}</span>))<span class="op">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        <span class="pp">Action::</span>SetTweak(<span class="pp">Tweak::</span>Highlight <span class="op">{</span> value<span class="op">:</span> <span class="cn">true</span> <span class="op">}</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>        )<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>  <span class="op">}</span></span></code></pre></div>
<h3 id="the-arglist">The arglist</h3>
<p>For the initial pass, I decided to handle imports, this was a simple find and replace operation, done to all the files containing tests. Luckily, modules (and therefore files) containing tests in Rust are annotated with the <code>#[cfg(test)]</code> attribute. I opened all such files:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co"># `grep -l pattern files` lists all the files</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="co">#  matching the pattern</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ex">vim</span> <span class="va">$(</span><span class="fu">grep</span> -l <span class="st">&#39;cfg\(test\)&#39;</span> ./**/*.rs<span class="va">)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="co"># expands to something like:</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="ex">vim</span> push_rules.rs room/member.rs key/verification/lib.rs</span></code></pre></div>
<p>Starting vim with more than one file at the shell prompt populates the arglist. Hit <code>:args</code> to see the list of files currently ready to edit. The square [brackets] indicate the current file. Navigate through the arglist with <code>:next</code> and <code>:prev</code>. I use tpope’s vim-unimpaired <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, which adds <code>]a</code> and <code>[a</code>, mapped to <code>:next</code> and <code>:prev</code>.</p>
<p>All that’s left to do is the find and replace, for which we will be using vim’s <code>argdo</code>, applying a substitution to every file in the arglist:</p>
<pre><code>:argdo s/from_str/from_value/g</code></pre>
<h3 id="the-quickfix-list">The quickfix list</h3>
<p>Next up, replacing <code>r#" ... "#</code> with <code>json!( ... )</code>. I couldn’t search and replace that trivially, so I went with a macro call <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> instead, starting with the cursor on ‘r’, represented by the caret, in my attempt to breakdown the process:</p>
<pre><code>BUFFER:    r#&quot; ... &quot;#;
           ^

ACTION:    vllsjson!(

BUFFER     json!( ... &quot;#;
                ^

ACTION:    &lt;esc&gt;$F#

BUFFER:    json!( ... &quot;#;
                       ^

ACTION:    vhs)&lt;esc&gt;

BUFFER:    json!( ... );</code></pre>
<p>Here’s the recorded <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> macro in all its glory: <code>vllsjson!(&lt;esc&gt;$F#vhs)&lt;esc&gt;</code>.</p>
<p>Great! So now we just go ahead, find every occurrence of <code>r#</code> and apply the macro right? Unfortunately, there were more than a few occurrences of raw strings that had to stay raw strings. Enter, the quickfix list.</p>
<p>The idea behind the quickfix list is to jump from one position in a file to another (maybe in a different file), much like how the arglist lets you jump from one file to another.</p>
<p>One of the easiest ways to populate this list with a bunch of positions is to use <code>vimgrep</code>:</p>
<pre><code># basic usage
:vimgrep pattern files

# search for raw strings
:vimgrep &#39;r#&#39; ./**/*.rs</code></pre>
<p>Like <code>:next</code> and <code>:prev</code>, you can navigate the quickfix list with <code>:cnext</code> and <code>:cprev</code>. Every time you move up or down the list, vim indicates your index:</p>
<pre><code>(1 of 131): r#&quot;{&quot;set_tweak&quot;: &quot;highlight&quot;}&quot;#;</code></pre>
<p>And just like <code>argdo</code>, you can <code>cdo</code> to apply commands to <em>every</em> match in the quickfix list:</p>
<pre><code>:cdo norm! @q</code></pre>
<p>But, I had to manually pick out matches, and it involved some button mashing.</p>
<h3 id="external-filtering">External Filtering</h3>
<p>Some code reviews later, I was asked to format all the json inside the <code>json!</code> macro. All you have to do is pass a visual selection through a pretty json printer. Select the range to be formatted in visual mode, and hit <code>:</code>, you will notice the command line displaying what seems to be gibberish:</p>
<pre><code>:&#39;&lt;,&#39;&gt;</code></pre>
<p><code>'&lt;</code> and <code>'&gt;</code> are <em>marks</em> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. More specifically, they are marks that vim sets automatically every time you make a visual selection, denoting the start and end of the selection.</p>
<p>A range is one or more line specifiers separated by a <code>,</code>:</p>
<pre><code>:1,7       lines 1 through 7
:32        just line 32
:.         the current line
:.,$       the current line to the last line
:&#39;a,&#39;b     mark &#39;a&#39; to mark &#39;b&#39;</code></pre>
<p>Most <code>:</code> commands can be prefixed by ranges. <code>:help usr_10.txt</code> for more on that.</p>
<p>Alright, lets pass json through <code>python -m json.tool</code>, a json formatter that accepts <code>stdin</code> (note the use of <code>!</code> to make use of an external program):</p>
<pre><code>:&#39;&lt;,&#39;&gt;!python -m json.tool</code></pre>
<p>Unfortunately that didn’t quite work for me because the range included some non-json text as well, a mix of regex and macros helped fix that. I think you get the drift.</p>
<p>Another fun filter I use from time to time is <code>:!sort</code>, to sort css attributes, or <code>:!uniq</code> to remove repeated imports.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>https://github.com/tpope/vim-unimpaired It also handles various other mappings, <code>]q</code> and <code>[q</code> to navigate the quickfix list for example<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><code>:help recording</code><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>When I’m recording a macro, I prefer starting out by storing it in register <code>q</code>, and then copying it over to another register if it works as intended. I think of <code>qq</code> as ‘quick record’.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><code>:help mark-motions</code><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></description>
<link>https://peppe.rs/posts/rapid_refactoring_with_vim/</link>
<pubDate>Wed, 01 Apr 2020 06:29:00 +0000</pubDate>
<guid>https://peppe.rs/posts/rapid_refactoring_with_vim/</guid>
</item>
<item>
<title>Font Size Fallacies</title>
<description><p>I am not an expert with fonts, but I do have some experience <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, and common sense. This post aims to debunk some misconceptions about font sizes!</p>
<p>11 px on your display is <em>probably not</em> 11 px on my display. Let’s do some quick math. I have two displays, 1366x768 @ 21" and another with 1920x1080 @ 13", call them <code>A</code> and <code>B</code> for now.</p>
<p>Display <code>A</code> has 1,049,088 pixels. A pixel is a square, of side say, <code>s</code> cm. The total area covered by my 21" display is about 1,066 cm^2 (41x26). Thus,</p>
<pre><code>Display A
Dimensions: 1366x768 @ 21&quot; (41x26 sq. cm)
1,049,088 s^2 = 1066
            s = 0.0318 cm (side of a pixel on Display A)</code></pre>
<p>Bear with me, as I repeat the number crunching for Display <code>B</code>:</p>
<pre><code>Display B
Dimensions: 1920x1080 @ 13&quot; (29.5x16.5 sq. cm)
2,073,600 s^2 = 486.75
            s = 0.0153 cm (side of a pixel on Display B)</code></pre>
<p>The width of a pixel on Display <code>A</code> is <em>double</em> the width of a pixel on Display <code>B</code>. The area occupied by a pixel on Display <code>A</code> is <em>4 times</em> the area occupied by a pixel on Display <code>B</code>.</p>
<p><em>The size of a pixel varies from display to display!</em></p>
<p>A 5x11 bitmap font on Display <code>A</code> would be around 4 mm tall whereas the same bitmap font on Display <code>B</code> would be around 1.9 mm tall. A 11 px tall character on <code>B</code> is visually equivalent to a 5 px character on <code>A</code>. When you view a screenshot of Display <code>A</code> on Display <code>B</code>, the contents are shrunk down by a factor of 2!</p>
<p>So screen resolution is not enough, how else do we measure size? Pixel Density! Keen readers will realize that the 5^th grade math problem we solved up there showcases pixel density, or, pixels per cm (PPCM). Usually we deal with pixels per inch (PPI).</p>
<p><strong>Note:</strong> PPI is not to be confused with DPI <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> (dots per inch). DPI is defined for printers.</p>
<p>In our example, <code>A</code> is a 75 ppi display and <code>B</code> is around 165 ppi <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. A low ppi display appears to be ‘pixelated’, because the pixels are more prominent, much like Display <code>A</code>. A higher ppi usually means you can view larger images and render crispier fonts. The average desktop display can stuff 100-200 pixels per inch. Smart phones usually fall into the 400-600 ppi (XXXHDPI) category. The human eye fails to differentiate detail past 300 ppi.</p>
<p><em>So … streaming an 8K video on a 60" TV provides the same clarity as a HD video on a smart phone?</em></p>
<p>Absolutely. Well, clarity is subjective, but the amount of detail you can discern on mobile displays has always been limited. Salty consumers of the Xperia 1 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> will say otherwise.</p>
<p>Maybe I will talk about font rendering in another post, but thats all for now. Don’t judge a font size by its screenshot.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>https://github.com/nerdypepper/scientifica<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Dots_per_inch<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>https://www.sven.de/dpi/<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>https://en.wikipedia.org/wiki/Sony_Xperia_1<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></description>
<link>https://peppe.rs/posts/font_size_fallacies/</link>
<pubDate>Tue, 17 Mar 2020 16:52:00 +0000</pubDate>
<guid>https://peppe.rs/posts/font_size_fallacies/</guid>
</item>
<item>
<title>Termux Tandem</title>
<description><p>I learnt about <code>termux</code> from a friend on IRC recently. It looked super gimmicky to me at first, but it eventually proved to be useful. Here’s what I use it for:</p>
<h3 id="rsync">rsync</h3>
<p>Ever since I degoogled my android device, syncing files between my phone and my PC has always been a pain. I’m looking at you MTP. But, with <code>termux</code> and <code>sshd</code> all set up, it’s as simple as:</p>
<pre><code>$ arp
Address         HWtype  HWad ...
192.168.43.187  ether   d0:0 ...

$ rsync -avz 192.168.43.187:~/frogs ~/pics/frogs</code></pre>
<h3 id="ssh-tmux">ssh &amp; tmux</h3>
<p>My phone doubles as a secondary view into my main machine with <code>ssh</code> and <code>tmux</code>. When I am away from my PC (read: sitting across the room), I check build status and IRC messages by <code>ssh</code>ing into a tmux session running the said build or weechat.</p>
<h3 id="file-uploads">file uploads</h3>
<p>Not being able to access my (ssh-only) file host was crippling. With a <code>bash</code> instance on my phone, I just copied over my ssh keys, and popped in a file upload script (a glorified <code>scp</code>). Now I just have to figure out a way to clean up these file names …</p>
<pre><code>~/storage/pictures/ $ ls
02muf5g7b2i41.jpg  7alt3cwg77841.jpg  cl4bsrge7id11.png
mtZabXG.jpg        p8d5c584f2841.jpg  vjUxGjq.jpg</code></pre>
<h3 id="cmus">cmus</h3>
<p>Alright, I don’t really listen to music via <code>cmus</code>, but I did use it a couple times when my default music player was acting up. <code>cmus</code> is a viable option:</p>
<p><a href="https://u.peppe.rs/CP.jpg"><img src="https://u.peppe.rs/CP.jpg" /></a></p></description>
<link>https://peppe.rs/posts/termux_tandem/</link>
<pubDate>Sun, 08 Mar 2020 16:47:00 +0000</pubDate>
<guid>https://peppe.rs/posts/termux_tandem/</guid>
</item>
<item>
<title>Call To ARMs</title>
<description><p>My 4th semester involves ARM programming. And proprietary tooling (Keil C). But we don’t do that here.</p>
<h3 id="building">Building</h3>
<p>Assembling and linking ARM binaries on non-ARM architecture devices is fairly trivial. I went along with the GNU cross bare metal toolchain binutils, which provides <code>arm-as</code> and <code>arm-ld</code> (among a bunch of other utils that I don’t care about for now).</p>
<p>Assemble <code>.s</code> files with:</p>
<pre class="shell"><code>arm-none-eabi-as main.s -g -march=armv8.1-a -o main.out</code></pre>
<p>The <code>-g</code> flag generates extra debugging information that <code>gdb</code> picks up. The <code>-march</code> option establishes target architecture.</p>
<p>Link <code>.o</code> files with:</p>
<pre class="shell"><code>arm-none-eabi-ld main.out -o main</code></pre>
<h3 id="running-and-debugging">Running (and Debugging)</h3>
<p>Things get interesting here. <code>gdb</code> on your x86 machine cannot read nor execute binaries compiled for ARM. So, we simulate an ARM processor using <code>qemu</code>. Now qemu allows you to run <code>gdbserver</code> on startup. Connecting our local <code>gdb</code> instance to <code>gdbserver</code> gives us a view into the program’s execution. Easy!</p>
<p>Run <code>qemu</code>, with <code>gdbserver</code> on port <code>1234</code>, with our ARM binary, <code>main</code>:</p>
<pre class="shell"><code>qemu-arm -singlestep -g 1234 main</code></pre>
<p>Start up <code>gdb</code> on your machine, and connect to <code>qemu</code>’s <code>gdbserver</code>:</p>
<pre><code>(gdb) set architecture armv8-a
(gdb) target remote localhost:1234
(gdb) file main
Reading symbols from main...  # yay!</code></pre>
<h3 id="gdb-enhanced">GDB Enhanced</h3>
<p><code>gdb</code> is cool, but it’s not nearly as comfortable as well fleshed out emulators/IDEs like Keil. Watching registers, CPSR and memory chunks update <em>is</em> pretty fun.</p>
<p>I came across <code>gdb</code>’s TUI mode (hit <code>C-x C-a</code> or type <code>tui enable</code> at the prompt). TUI mode is a godsend. It highlights the current line of execution, shows you disassembly outputs, updated registers, active breakpoints and more.</p>
<p><em>But</em>, it is an absolute eyesore.</p>
<p>Say hello to <a href="https://github.com/hugsy/gef">GEF</a>! “GDB Enhanced Features” teaches our old dog some cool new tricks. Here are some additions that made my ARM debugging experience loads better:</p>
<ul>
<li>Memory watches</li>
<li>Register watches, with up to 7 levels of deref (overkill, I agree)</li>
<li>Stack tracing</li>
</ul>
<p>And it’s pretty! See for yourself:</p>
<p><a href="https://u.peppe.rs/wq.png"><img src="https://u.peppe.rs/wq.png" /></a></p>
<h3 id="editing">Editing</h3>
<p>Vim, with <code>syntax off</code> because it dosen’t handle GNU ARM syntax too well.</p></description>
<link>https://peppe.rs/posts/call_to_ARMs/</link>
<pubDate>Fri, 07 Feb 2020 18:30:00 +0000</pubDate>
<guid>https://peppe.rs/posts/call_to_ARMs/</guid>
</item>
<item>
<title>Color Conundrum</title>
<description><p>This piece aims to highlight (pun intended) some of the reasons behind my <a href="https://u.peppe.rs/bF.png">color free</a> editor setup.</p>
<p>Imagine highlighting an entire book because <em>all</em> of it is important. That is exactly what (most) syntax highlighting does. It is difficult for the human eye to filter out noise in rainbow barf. Use color to draw attention, not diverge it.</p>
<p>At the same time, a book devoid of color is <em>boring!</em> What is the takeaway from this 10 line paragraph? What are the technical terms used?</p>
<p>Prose and code are certainly different, but the fickle minded human eye is the same. The eye constantly looks for a frame of reference, a focal point. It grows tired when it can’t find one.</p>
<p>The following comparison does a better job of explaining (none, ample and over-the-top highlighting, from left to right):</p>
<p><a href="https://u.peppe.rs/lt.png"><img src="https://u.peppe.rs/lt.png" /></a></p>
<p>Without highlighting (far left), it is hard to differentiate between comments and code! The florid color scheme (far right) is no good either, it contains too many attention grabbers. The center sample is a healthy balance of both. Function calls and constants stand out, and repetitive keywords and other noise (<code>let</code>, <code>as</code>) are mildly dimmed out. Comments and non-code text (sign column, status text) are dimmed further.</p>
<p>I’ll stop myself before I rant about color contrast and combinations.</p></description>
<link>https://peppe.rs/posts/color_conundrum/</link>
<pubDate>Mon, 30 Dec 2019 18:30:00 +0000</pubDate>
<guid>https://peppe.rs/posts/color_conundrum/</guid>
</item>
<item>
<title>Static Sites With Bash</title>
<description><p>After going through a bunch of static site generators (<a href="https://blog.getpelican.com/">pelican</a>, <a href="https://gohugo.io">hugo</a>, <a href="https://github.com/icyphox/vite">vite</a>), I decided to roll my own. If you are more of the ‘show me the code’ kinda guy, <a href="https://github.com/nerdypepper/site">here</a> you go.</p>
<h3 id="text-formatting">Text formatting</h3>
<p>I chose to write in markdown, and convert to html with <a href="https://kristaps.bsd.lv/lowdown/">lowdown</a>.</p>
<h3 id="directory-structure">Directory structure</h3>
<p>I host my site on GitHub pages, so <code>docs/</code> has to be the entry point. Markdown formatted posts go into <code>posts/</code>, get converted into html, and end up in <code>docs/index.html</code>, something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="va">posts=$(</span><span class="fu">ls</span> -t ./posts<span class="va">)</span>     <span class="co"># chronological order!</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">for</span> <span class="ex">f</span> in <span class="va">$posts</span><span class="kw">;</span> <span class="kw">do</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="va">file=</span><span class="st">&quot;./posts/&quot;</span><span class="va">$f</span>      <span class="co"># `ls` mangled our file paths</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="bu">echo</span> <span class="st">&quot;generating post </span><span class="va">$file</span><span class="st">&quot;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="va">html=$(</span><span class="ex">lowdown</span> <span class="st">&quot;</span><span class="va">$file</span><span class="st">&quot;</span><span class="va">)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="bu">echo</span> -e <span class="st">&quot;html&quot;</span> <span class="op">&gt;&gt;</span> docs/index.html</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">done</span></span></code></pre></div>
<h3 id="assets">Assets</h3>
<p>Most static site generators recommend dropping image assets into the site source itself. That does have it’s merits, but I prefer hosting images separately:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co"># strip file extension</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="va">ext=</span><span class="st">&quot;</span><span class="va">${1##</span>*.<span class="va">}</span><span class="st">&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co"># generate a random file name</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="va">id=$(</span> <span class="fu">cat</span> /dev/urandom <span class="kw">|</span> <span class="fu">tr</span> -dc <span class="st">&#39;a-zA-Z0-9&#39;</span> <span class="kw">|</span> <span class="ex">fold</span> -w 2 <span class="kw">|</span> <span class="fu">head</span> -n 1 <span class="va">)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="va">id=</span><span class="st">&quot;</span><span class="va">$id</span><span class="st">.</span><span class="va">$ext</span><span class="st">&quot;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="co"># copy to my file host</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="fu">scp</span> -P 443 <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span> emerald:files/<span class="st">&quot;</span><span class="va">$id</span><span class="st">&quot;</span> </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="bu">echo</span> <span class="st">&quot;https://u.peppe.rs/</span><span class="va">$id</span><span class="st">&quot;</span></span></code></pre></div>
<h3 id="templating">Templating</h3>
<p><a href="https://github.com/NerdyPepper/site/blob/master/generate.sh"><code>generate.sh</code></a> brings the above bits and pieces together (with some extra cruft to avoid javascript). It uses <code>sed</code> to produce nice titles from the file names (removes underscores, title-case), and <code>date(1)</code> to add the date to each post listing!</p></description>
<link>https://peppe.rs/posts/static_sites_with_bash/</link>
<pubDate>Fri, 22 Nov 2019 18:30:00 +0000</pubDate>
<guid>https://peppe.rs/posts/static_sites_with_bash/</guid>
</item>
<item>
<title>My Setup</title>
<description><p>Decided to do one of these because everyone does one of these.</p>
<p><img src="https://u.peppe.rs/Hb.png" /></p>
<p>My entire setup is managed with GNU <code>stow</code>, making it easier to replicate on fresh installations. You can find my configuration files on <a href="https://github.com/nerdypepper">GitHub</a>.</p>
<p>I run Void Linux (glibc) on my <a href="https://store.hp.com/us/en/mdp/laptops/envy-13">HP Envy 13" (2018)</a>. To keep things simple, I run a raw X session with <code>2bwm</code> as my window manager, along with <code>dunst</code> (notification daemon) and Sam’s <a href="https://github.com/sdhand/compton"><code>compton</code></a> (compositor) fork.</p>
<p>I am a fan of GNU tools, so I use <code>bash</code> as my shell, and <code>coreutils</code> to manage files, archives, strings, paths etc. I edit files with <code>vim</code>, chat with <code>weechat</code>, listen to music with <code>cmus</code>, monitor processes with <code>htop</code>, manage sessions with <code>tmux</code>, read pdfs in <code>zathura</code>. I rarely ever leave the comfort of my terminal emulator, <code>urxvt</code>.</p>
<p>Most of my academic typesetting is done with TeX, and compiled with <code>xelatex</code>. Other <em>fun</em> documents are made with GIMP :).</p></description>
<link>https://peppe.rs/posts/my_setup/</link>
<pubDate>Wed, 06 Nov 2019 18:30:00 +0000</pubDate>
<guid>https://peppe.rs/posts/my_setup/</guid>
</item>
<item>
<title>WPA Woes</title>
<description><p>I finally got around to installing Void GNU/Linux on my main computer. Rolling release, non-systemd, need I say more?</p>
<p>As with all GNU/Linux distributions, wireless networks had me in a fix. If you can see this post, it means I’ve managed to get online. It turns out, <code>wpa_supplicant</code> was detecting the wrong interface by default (does it ever select the right one?). Let us fix that:</p>
<pre><code>$ sudo rm -r /var/service/wpa_supplicant
$ sudo killall dhcpcd</code></pre>
<p>What is the right interface though?</p>
<pre><code>$ iw dev
   ...
   Interface wlp2s0
   ...</code></pre>
<p>Aha! Let us run <code>wpa_supplicant</code> on that interface, as a background process:</p>
<pre><code>$ sudo wpa_supplicant -B -i wlp2s0 -c /etc/wpa_supplicant/wpa_supplicant.conf
$ sudo dhcpcd -B wlp2s0
$ ping google.com
PING ...</code></pre>
<p>Yay! Make those changes perpetual by enabling the service:</p>
<pre><code>------------------------------------------------------
# Add these to /etc/wpa_supplicant/wpa_supplicant.conf
OPTS=&quot;-B&quot;
WPA_INTERFACE=&quot;wlp2s0&quot;
------------------------------------------------------
$ sudo ln -s /etc/sv/wpa_supplicant /var/service/
$ sudo ln -s /etc/sv/dhcpcd /var/service/
$ sudo sv restart wpa_supplicant
$ sudo sv restart dhcpcd</code></pre></description>
<link>https://peppe.rs/posts/WPA_woes/</link>
<pubDate>Sat, 12 Oct 2019 16:18:00 +0000</pubDate>
<guid>https://peppe.rs/posts/WPA_woes/</guid>
</item>
<item>
<title>Bye Bye BDFs</title>
<description><p>Glyph Bitmap Distribution Format is no more, as the creators of <a href="https://pango.org">Pango</a>, one of the most widely used text rendering libraries, <a href="https://blogs.gnome.org/mclasen/2019/05/25/pango-future-directions/">announced</a> their plans for Pango 1.44.</p>
<p>Until recently, Pango used FreeType to draw fonts. They will be moving over to <a href="https://harfbuzz.org">Harfbuzz</a>, an evolution of FreeType.</p>
<p><em>Why?</em></p>
<p>In short, FreeType was hard to work with. It required complex logic, and provided no advantage over Harfbuzz (other than being able to fetch opentype metrics with ease).</p>
<p>Upgrading to Pango v1.44 will break your GTK applications (if you use a <code>bdf</code>/<code>pcf</code> bitmap font). Harfbuzz <em>does</em> support bitmap-only OpenType fonts, <code>otb</code>s. Convert your existing fonts over to <code>otb</code>s using <a href="https://fontforge.github.io">FontForge</a>. It is to be noted that applications such as <code>xterm</code> and <code>rxvt</code> use <code>xft</code> (X FreeType) to render fonts, and will remain unaffected by the update.</p>
<p>Both <a href="https://github.com/nerdypepper/scientifica">scientifica</a> and <a href="https://github.com/nerdypepper/curie">curie</a> will soon ship with bitmap-only OpenType font formats.</p></description>
<link>https://peppe.rs/posts/bye_bye_BDFs/</link>
<pubDate>Wed, 07 Aug 2019 12:31:00 +0000</pubDate>
<guid>https://peppe.rs/posts/bye_bye_BDFs/</guid>
</item>
<item>
<title>Onivim Sucks</title>
<description><p><a href="https://v2.onivim.io">Onivim</a> is a ‘modern modal editor’, combining fancy interface and language features with vim-style modal editing. What’s wrong you ask?</p>
<p>Apart from <a href="https://github.com/onivim/oni2/issues/550">buggy syntax highlighting</a>, <a href="https://github.com/onivim/oni2/issues/519">broken scrolling</a> and <a href="https://github.com/onivim/oni2/issues?q=is%3Aissue+label%3A%22daily+editor+blocker%22+is%3Aopen">others</a>, Onivim is <strong>proprietary</strong> software. It is licensed under a commercial <a href="https://github.com/onivim/oni1/blob/master/Outrun-Labs-EULA-v1.1.md">end user agreement license</a>, which prohibits redistribution in both object code and source code formats.</p>
<p>Onivim’s core editor logic (bits that belong to vim), have been separated from the interface, into <a href="https://github.com/onivim/libvim">libvim</a>. libvim is licensed under MIT, which means, this ‘extension’ of vim is perfectly in adherence to <a href="http://vimdoc.sourceforge.net/htmldoc/uganda.html#license">vim’s license text</a>! Outrun Labs are exploiting this loophole (distributing vim as a library) to commercialize Onivim.</p>
<p>Onivim’s source code is available on <a href="https://github.com/onivim/oni2">GitHub</a>. They do mention that the source code trickles down to the <a href="https://github.com/onivim/oni2-mit">oni2-mit</a> repository, which (not yet) contains MIT-licensed code, <strong>18 months</strong> after each commit to the original repository.</p>
<p>Want to contribute to Onivim? Don’t. They make a profit out of your contributions. Currently, Onivim is priced at $19.99, ‘pre-alpha’ pricing which is 80% off the final price! If you are on the lookout for an editor, I would suggest using <a href="https://vim.org">Vim</a>, charity ware that actually works, and costs $100 lesser.</p></description>
<link>https://peppe.rs/posts/onivim_sucks/</link>
<pubDate>Fri, 02 Aug 2019 12:31:00 +0000</pubDate>
<guid>https://peppe.rs/posts/onivim_sucks/</guid>
</item>
<item>
<title>Bash Harder With Vim</title>
<description><p>Bash is tricky, don’t let your editor get in your way. Here’s a couple of neat additions you could make to your <code>vimrc</code> for a better shell programming experience.</p>
<h3 id="man-pages-inside-vim">Man pages inside vim</h3>
<p>Source this script to get started:</p>
<pre><code>runtime ftplugin/man.vim</code></pre>
<p>Now, you can open manpages inside vim with <code>:Man</code>! It adds nicer syntax highlighting and the ability to jump around with <code>Ctrl-]</code> and <code>Ctrl-T</code>.</p>
<p>By default, the manpage is opened in a horizontal split, I prefer using a new tab:</p>
<pre><code>let g:ft_man_open_mode = &#39;tab&#39;</code></pre>
<h3 id="scratchpad-to-test-your-commands">Scratchpad to test your commands</h3>
<p>I often test my <code>sed</code> substitutions, here is a sample from the script used to generate this site:</p>
<pre><code># a substitution to convert snake_case to Title Case With Spaces
echo &quot;$1&quot; | sed -E -e &quot;s/\..+$//g&quot;  -e &quot;s/_(.)/ \u\1/g&quot; -e &quot;s/^(.)/\u\1/g&quot;</code></pre>
<p>Instead of dropping into a new shell, just test it out directly from vim!</p>
<ul>
<li>Yank the line into a register:</li>
</ul>
<pre><code>yy</code></pre>
<ul>
<li>Paste it into the command-line window:</li>
</ul>
<pre><code>q:p</code></pre>
<ul>
<li>Make edits as required:</li>
</ul>
<pre><code>syntax off            # previously run commands
edit index.html       # in a buffer!
w | so %
!echo &quot;new_post.md&quot; | sed -E -e &quot;s/\..+$//g&quot;  --snip--
^--- note the use of &#39;!&#39;</code></pre>
<ul>
<li>Hit enter with the cursor on the line containing your command!</li>
</ul>
<pre><code>$ vim
New Post         # output
Press ENTER or type command to continue</code></pre></description>
<link>https://peppe.rs/posts/bash_harder_with_vim/</link>
<pubDate>Wed, 31 Jul 2019 06:30:00 +0000</pubDate>
<guid>https://peppe.rs/posts/bash_harder_with_vim/</guid>
</item>
<item>
<title>Hold Position!</title>
<description><p>Often times, when I run a vim command that makes “big” changes to a file (a macro or a <code>:vimgrep</code> command) I lose my original position and feel disoriented.</p>
<p><em>Save position with <code>winsaveview()</code>!</em></p>
<p>The <code>winsaveview()</code> command returns a <code>Dictionary</code> that contains information about the view of the current window. This includes the cursor line number, cursor coloumn, the top most line in the window and a couple of other values, none of which concern us.</p>
<p>Before running our command (one that jumps around the buffer, a lot), we save our view, and restore it once its done, with <code>winrestview</code>.</p>
<pre><code>let view = winsaveview()
s/\s\+$//gc              &quot; find and (confirm) replace trailing blanks
winrestview(view)        &quot; restore our original view!</code></pre>
<p>It might seem a little overkill in the above example, just use `` (double backticks) instead, but it comes in handy when you run your file through heavier filtering.</p></description>
<link>https://peppe.rs/posts/hold_position!/</link>
<pubDate>Tue, 30 Jul 2019 12:31:00 +0000</pubDate>
<guid>https://peppe.rs/posts/hold_position!/</guid>
</item>
<item>
<title>Get Better At Yanking And Putting In Vim</title>
<description><p>a couple of nifty tricks to help you copy-paste better:</p>
<ol type="1">
<li><p>reselecting previously selected text (i use this to fix botched selections):</p>
<pre><code>gv  &quot; :h gv for more
    &quot; you can use `o` in visual mode to go to the `Other` end of the selection
    &quot; use a motion to fix the selection</code></pre></li>
<li><p>reselecting previously yanked text:</p>
<pre><code>`[v`]
`[         &quot; marks the beginning of the previously yanked text   :h `[
`]         &quot; marks the end                                       :h `]
 v         &quot; visual select everything in between

nnoremap gb `[v`]    &quot; &quot;a quick map to perform the above</code></pre></li>
<li><p>pasting and indenting text (in one go):</p>
<pre><code>]p   &quot; put (p) and adjust indent to current line
]P   &quot; put the text before the cursor (P) and adjust indent to current line</code></pre></li>
</ol></description>
<link>https://peppe.rs/posts/get_better_at_yanking_and_putting_in_vim/</link>
<pubDate>Mon, 29 Jul 2019 12:31:00 +0000</pubDate>
<guid>https://peppe.rs/posts/get_better_at_yanking_and_putting_in_vim/</guid>
</item>


    </channel>
</rss>
